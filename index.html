<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@100;200;300;400;500;600&display=swap" rel="stylesheet">
    <title>OStudio</title>
    <style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { height: 100%; }
body {
    font-family: 'Poppins', sans-serif;
    background: #f5f5f5;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
}
.container {
    position: relative;
    width: 100%;
    height: 100dvh;
    display: flex;
    align-items: center;
    justify-content: center;
}
#orbyte-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
    pointer-events: auto;
    transform: translateZ(0);
    will-change: transform;
}
.content {
    position: relative;
    z-index: 20;
    text-align: center;
    pointer-events: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 24px;
}
.logo-area { pointer-events: auto; }
.logo-img {
    max-width: 380px;
    width: 100%;
    height: auto;
    display: block;
    animation: logoDrop 1.2s cubic-bezier(.22,1,.36,1) forwards;
    opacity: 0;
}
.btn-outline {
    pointer-events: auto;
    display: inline-block;
    padding: 5px 28px 7px 28px;
    border: 1px solid #000;
    border-radius: 50px;
    color: black;
    text-decoration: none;
    font-size: 16px;
    font-weight: 300;
    transition: all 0.2s ease;
    background: transparent;
    margin-top: 120px;
    animation: buttonRise 1.2s cubic-bezier(.22,1,.36,1) forwards;
    animation-delay: .4s;
    opacity: 0;
}
.tagline {
    font-size: 16px;
    color: black;
    line-height: 1.6;
    animation: fadeTag 1.4s ease forwards;
    animation-delay: .4s;
    opacity: 0;
    position: fixed;
    bottom: 15px;
    font-weight: 400;
    text-align: center;
}
@keyframes logoDrop {
    from { transform: translateY(-40px); opacity: 0; }
    to   { transform: translateY(0);     opacity: 1; }
}
@keyframes buttonRise {
    from { transform: translateY(40px); opacity: 0; }
    to   { transform: translateY(0);    opacity: 1; }
}
@keyframes fadeTag {
    from { opacity: 0; transform: translateY(15px); }
    to   { opacity: 1; transform: translateY(0); }
}
@media (max-width: 768px) {
    .logo-img { max-width: 200px; }
    .btn-outline { font-size: 13px; padding: 8px 22px; }
    .tagline { font-size: 13px; }
}
@media (max-width: 480px) {
    .logo-img { max-width: 200px; }
    .btn-outline { font-size: 12px; padding: 7px 18px; margin-top: 70px; }
    .tagline { font-size: 11px; }
}
    </style>
</head>
<body>
<div class="container">
    <canvas id="orbyte-canvas"></canvas>
</div>

<script>
(() => {
    const canvas = document.getElementById('orbyte-canvas');
    const ctx    = canvas.getContext('2d');

    let W, H, dpr;
    let particles    = [];
    let shapeTargets = [];
    let shapeReady   = false;
    let imgAspect    = 1;
    let introComplete  = false;
    let introStartTime = 0;

    // ── CONFIG ──────────────────────────────────────────────────────
    const PARTICLE_COUNT  = 22000;   // أقل = أسرع وأسلس
    const DOT_SIZE        = 0.75;
    const INTRO_DURATION  = 3500;    // ms — مدة التجمع
    const FACE_SCALE      = 0.72;    // نسبة الوجه من الشاشة

    const IMG_URL = 'img/face.jpeg';

    // ── EASING ──────────────────────────────────────────────────────
    // Smooth S-curve: slow → fast → slow — مفيش تقطيع
    function easeInOutQuart(t) {
        return t < 0.5 ? 8*t*t*t*t : 1 - Math.pow(-2*t+2, 4)/2;
    }
    function easeOutExpo(t) {
        return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    }

    // ── IMAGE LOADING ───────────────────────────────────────────────
    function loadShape() {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
            imgAspect = img.width / img.height;
            sampleShape(img);
            shapeReady = true;
            resize();
            requestAnimationFrame(animate);
        };
        img.src = IMG_URL;
    }

    function sampleShape(img) {
        const tmp = document.createElement('canvas');
        const tc  = tmp.getContext('2d');
        const sW  = 600, sH = Math.round(sW / (img.width / img.height));
        tmp.width = sW; tmp.height = sH;
        tc.drawImage(img, 0, 0, sW, sH);
        const data = tc.getImageData(0, 0, sW, sH).data;

        // Bounding box of content
        let minX = sW, maxX = 0, minY = sH, maxY = 0;
        for (let y = 0; y < sH; y++) for (let x = 0; x < sW; x++) {
            const i = (y*sW+x)*4;
            if ((data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114) < 210) {
                if (x<minX) minX=x; if (x>maxX) maxX=x;
                if (y<minY) minY=y; if (y>maxY) maxY=y;
            }
        }
        const pad = 20;
        minX=Math.max(0,minX-pad); maxX=Math.min(sW-1,maxX+pad);
        minY=Math.max(0,minY-pad); maxY=Math.min(sH-1,maxY+pad);
        const cW = maxX-minX, cH = maxY-minY;

        const candidates = [];
        for (let y=0; y<sH; y++) for (let x=0; x<sW; x++) {
            const i = (y*sW+x)*4;
            if (data[i+3] < 30) continue;
            const bright = data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114;
            const dark   = 1 - bright/255;
            if (dark < 0.04) continue;

            let prob;
            if      (dark > 0.55) prob = Math.pow(dark, 0.9) * 0.90;
            else if (dark > 0.30) prob = Math.pow(dark, 1.2) * 0.55;
            else                  prob = Math.pow(dark, 1.9) * 0.28;

            if (Math.random() < prob) {
                candidates.push({ nx:(x-minX)/cW, ny:(y-minY)/cH, d:dark });
            }
        }

        // Scatter haze outward from edges
        const edges = candidates.filter(p => p.d>0.08 && p.d<0.32);
        const sc    = Math.min(4000, edges.length*2);
        for (let i=0; i<sc; i++) {
            const src   = edges[Math.floor(Math.random()*edges.length)];
            const angle = Math.random()*Math.PI*2;
            const dist  = Math.random()*0.12 + 0.015;
            const nx    = src.nx + Math.cos(angle)*dist*1.4;
            const ny    = src.ny + Math.sin(angle)*dist;
            if (nx>=-0.2&&nx<=1.2&&ny>=-0.15&&ny<=1.15) {
                const fd = src.d*(1-dist/0.14)*0.55;
                if (fd>0.018) candidates.push({ nx, ny, d:fd });
            }
        }

        // Shuffle → take N
        for (let i=candidates.length-1;i>0;i--) {
            const j=Math.floor(Math.random()*(i+1));
            [candidates[i],candidates[j]]=[candidates[j],candidates[i]];
        }
        shapeTargets = candidates.slice(0, PARTICLE_COUNT);
    }

    // ── FACE DIMENSIONS ─────────────────────────────────────────────
    function getFaceDims() {
        const maxW = W * FACE_SCALE;
        const maxH = H * FACE_SCALE;
        let dW, dH;
        if (maxW/imgAspect <= maxH) { dW=maxW; dH=maxW/imgAspect; }
        else                         { dH=maxH; dW=maxH*imgAspect; }
        return { dW, dH, ox:(W-dW)/2, oy:(H-dH)/2 };
    }

    // ── CREATIVE MOVEMENT: breathing + slow drift + ripple ──────────
    function getLivePos(target, t) {
        const { dW, dH, ox, oy } = getFaceDims();

        let x = ox + target.nx * dW;
        let y = oy + target.ny * dH;

        const faceCX = ox + dW*0.5;
        const faceCY = oy + dH*0.5;
        const dx = x - faceCX, dy = y - faceCY;
        const dist  = Math.sqrt(dx*dx + dy*dy);
        const maxD  = Math.sqrt(dW*dW + dH*dH)*0.5;
        const norm  = dist / maxD; // 0=center, 1=edge

        // 1. Breathing — الوجه بيتنفس (scale pulse)
        const breathe   = Math.sin(t * 0.38) * 0.008 * norm;
        x += dx * breathe;
        y += dy * breathe;

        // 2. Slow float — طفو بطيء عمودي
        const float = Math.sin(t * 0.22 + target.nx * 1.5) * 1.8 * norm;
        y += float;

        // 3. Ripple من الأطراف — موجة تنتشر للخارج
        const ripplePhase = norm * 4.5 - t * 1.1;
        const ripple      = Math.sin(ripplePhase) * 1.4 * Math.pow(norm, 1.5);
        x += (dx/Math.max(dist,1)) * ripple;
        y += (dy/Math.max(dist,1)) * ripple;

        // 4. Micro-turbulence على الأطراف
        if (norm > 0.55) {
            const turb = (norm - 0.55) * 1.8;
            x += Math.sin(target.ny*12 + t*1.6) * turb;
            y += Math.cos(target.nx*10 + t*1.3) * turb;
        }

        return { x, y };
    }

    // ── SPAWN ────────────────────────────────────────────────────────
    function spawnPoint() {
        const pad  = 250;
        const side = Math.floor(Math.random()*4);
        switch(side) {
            case 0: return { x: Math.random()*W,   y: -pad };
            case 1: return { x: Math.random()*W,   y: H+pad };
            case 2: return { x: -pad,               y: Math.random()*H };
            default:return { x: W+pad,              y: Math.random()*H };
        }
    }

    // ── RESIZE ───────────────────────────────────────────────────────
    function resize() {
        dpr = window.devicePixelRatio || 1;
        W   = window.innerWidth;
        H   = window.innerHeight;
        canvas.width  = W*dpr; canvas.height = H*dpr;
        canvas.style.width=W+'px'; canvas.style.height=H+'px';
        ctx.setTransform(dpr,0,0,dpr,0,0);
        if (shapeReady) initParticles();
    }

    // ── INIT PARTICLES ───────────────────────────────────────────────
    function initParticles() {
        particles      = [];
        introStartTime = performance.now();
        introComplete  = false;

        // Sort: center arrives first → outer last (natural gather feel)
        const sorted = shapeTargets
            .map((t,i) => ({ i, dist: Math.hypot(t.nx-0.5, t.ny-0.5) }))
            .sort((a,b) => a.dist - b.dist);

        for (let si=0; si<sorted.length; si++) {
            const t     = shapeTargets[sorted[si].i];
            const spawn = spawnPoint();
            const norm  = si / sorted.length; // 0=center, 1=edge

            // Alpha & size based on darkness tier
            let alpha, size;
            if (t.d > 0.55) {
                alpha = 0.65 + t.d*0.35;
                size  = DOT_SIZE * (0.55 + t.d*0.75);
            } else if (t.d > 0.30) {
                alpha = 0.30 + t.d*0.45;
                size  = DOT_SIZE * (0.38 + t.d*0.55);
            } else {
                alpha = 0.10 + t.d*0.55;
                size  = DOT_SIZE * (0.22 + t.d*0.5);
            }

            // Stagger: center=0 delay, edge=full delay + tiny random jitter
            const delay = norm * 0.75 + Math.random()*0.06;

            particles.push({
                target: t,
                x: spawn.x, y: spawn.y,
                sx: spawn.x, sy: spawn.y,   // start position
                vx: 0, vy: 0,               // velocity for spring
                alpha, size, delay,
            });
        }
    }

    // ── ANIMATE ──────────────────────────────────────────────────────
    function animate() {
        ctx.clearRect(0, 0, W, H);

        const now     = performance.now();
        const elapsed = now - introStartTime;
        const t       = now * 0.001; // seconds

        for (let i=0; i<particles.length; i++) {
            const p    = particles[i];
            const dest = getLivePos(p.target, t);

            let drawX, drawY, drawAlpha;

            if (!introComplete) {
                // Normalized time for this particle [0,1]
                const pStart    = p.delay * INTRO_DURATION;
                const pElapsed  = elapsed - pStart;
                const duration  = INTRO_DURATION * 0.58;
                const pt        = Math.min(Math.max(pElapsed/duration, 0), 1);

                // Position: easeInOutQuart — smooth S-curve, no snap
                const progress  = easeInOutQuart(pt);
                drawX = p.sx + (dest.x - p.sx) * progress;
                drawY = p.sy + (dest.y - p.sy) * progress;
                p.x   = drawX; p.y = drawY;

                // Alpha: delayed fade-in, easeOutExpo
                const aStart  = 0.12; // alpha starts after position starts
                const aT      = Math.min(Math.max((pt - aStart)/(1-aStart), 0), 1);
                drawAlpha     = p.alpha * easeOutExpo(aT);

                p.vx = 0; p.vy = 0; // reset velocity ready for post-intro

            } else {
                // Spring physics: smooth, no lerp jitter
                const stiff   = 0.042;
                const damp    = 0.74;
                p.vx = p.vx*damp + (dest.x - p.x)*stiff;
                p.vy = p.vy*damp + (dest.y - p.y)*stiff;
                p.x += p.vx;
                p.y += p.vy;
                drawX = p.x; drawY = p.y;
                drawAlpha = p.alpha;
            }

            ctx.beginPath();
            ctx.arc(drawX, drawY, p.size, 0, Math.PI*2);
            ctx.fillStyle = `rgba(0,0,0,${drawAlpha.toFixed(3)})`;
            ctx.fill();
        }

        if (!introComplete && elapsed > INTRO_DURATION*1.9) introComplete = true;
        requestAnimationFrame(animate);
    }

    // ── EVENTS ───────────────────────────────────────────────────────
    // Mouse hover removed as requested

    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(resize, 150);
    });

    loadShape();
})();
</script>
</body>
</html> -->





<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@100;200;300;400;500;600&display=swap" rel="stylesheet">
    <title>OStudio</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            height: 100%;
            width: 100%;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100dvh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* ── Frame Animation Wrapper ── */
        .frame-animation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            width: min(56vh, 80vw);
            aspect-ratio: 9 / 16;
            background: transparent;
        }

        .frame-animation img {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            /* opacity managed fully by JS — no CSS transition */
            opacity: 0;
            pointer-events: none;
            will-change: opacity;
            transform: translateZ(0);
        }

        /* ── Content layer ── */
        .content {
            position: relative;
            z-index: 20;
            text-align: center;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }

        .logo-area { pointer-events: auto; }

        .logo-img {
            max-width: 380px;
            width: 100%;
            height: auto;
            display: block;
            animation: logoDrop 1.2s cubic-bezier(.22,1,.36,1) forwards;
            opacity: 0;
        }

        .btn-outline {
            pointer-events: auto;
            display: inline-block;
            padding: 5px 28px 7px 28px;
            border: 1px solid #000;
            border-radius: 50px;
            color: black;
            text-decoration: none;
            font-size: 16px;
            font-weight: 300;
            transition: all 0.2s ease;
            background: transparent;
            margin-top: 120px;
            animation: buttonRise 1.2s cubic-bezier(.22,1,.36,1) forwards;
            animation-delay: .4s;
            opacity: 0;
        }

        .btn-outline:hover {
            background: #000;
            color: #fff;
        }

        .tagline {
            font-size: 16px;
            color: black;
            line-height: 1.6;
            animation: fadeTag 1.4s ease forwards;
            animation-delay: .4s;
            opacity: 0;
            position: fixed;
            bottom: 15px;
            font-weight: 400;
            text-align: center;
        }

        @keyframes logoDrop {
            from { transform: translateY(-40px); opacity: 0; }
            to   { transform: translateY(0);     opacity: 1; }
        }
        @keyframes buttonRise {
            from { transform: translateY(40px); opacity: 0; }
            to   { transform: translateY(0);    opacity: 1; }
        }
        @keyframes fadeTag {
            from { opacity: 0; transform: translateY(15px); }
            to   { opacity: 1; transform: translateY(0); }
        }

        /* ── Responsive ── */
        @media (max-width: 768px) {
            .frame-animation { width: min(60vh, 88vw); }
            .logo-img        { max-width: 200px; }
            .btn-outline     { font-size: 13px; padding: 8px 22px; }
            .tagline         { font-size: 13px; }
        }
        @media (max-width: 480px) {
            .frame-animation { width: min(62vh, 92vw); }
            .logo-img        { max-width: 200px; }
            .btn-outline     { font-size: 12px; padding: 7px 18px; margin-top: 70px; }
            .tagline         { font-size: 11px; }
        }
        @media (max-height: 500px) {
            .frame-animation { width: min(90vh, 55vw); }
        }
    </style>
</head>
<body>

<div class="container">

    <div class="frame-animation" id="frameAnim"></div>

    <div class="content">
        <!--
        <div class="logo-area">
            <img class="logo-img" src="img/logo.svg" alt="OStudio Logo">
        </div>
        <a href="#" class="btn-outline">Enter</a>
        <p class="tagline">Your tagline here</p>
        -->
    </div>

</div>

<script>
(function () {

    /* ══════════════════════════════════════════
       CONFIG
    ══════════════════════════════════════════ */
    const TOTAL_FRAMES = 144;
    const START_INDEX  = 0;
    const FPS          = 60;
    const FRAME_MS     = 1000 / FPS;          // ~16.67 ms per frame
    const IMG_FOLDER   = 'img/';
    const BASE_NAME    = 'freepik_-_veo3_1080p_9-16_24fps_6349_';
    const EXT          = '.jpg';

    /*
      CROSSFADE_MS — short blend, just enough to kill any hard cut.
      At 60fps each frame is ~16ms, so 12ms is enough to feel smooth.
    */
    const CROSSFADE_MS = 12;

    /* ══════════════════════════════════════════
       BUILD IMG ELEMENTS
    ══════════════════════════════════════════ */
    const pad = n => String(n).padStart(5, '0');

    const container = document.getElementById('frameAnim');
    const imgs = [];

    for (let i = 0; i < TOTAL_FRAMES; i++) {
        const img = document.createElement('img');
        img.src      = IMG_FOLDER + BASE_NAME + pad(START_INDEX + i) + EXT;
        img.alt      = '';
        img.draggable = false;
        if (i < 5) img.loading = 'eager';
        container.appendChild(img);
        imgs.push(img);
    }

    /* ══════════════════════════════════════════
       STATE
    ══════════════════════════════════════════ */
    let current    = 0;          // index of currently-visible frame
    let direction  = 1;          // +1 forward  /  -1 reverse
    let lastTime   = null;

    /* Cross-fade state */
    let fading     = false;
    let fadeFrom   = -1;
    let fadeTo     = -1;
    let fadeStart  = null;

    /* ══════════════════════════════════════════
       PING-PONG: next index + direction flip
    ══════════════════════════════════════════ */
    function nextIndex(cur, dir) {
        let next = cur + dir;

        if (next >= TOTAL_FRAMES) {
            next = TOTAL_FRAMES - 2;   // step back from last
            dir  = -1;
        } else if (next < 0) {
            next = 1;                  // step forward from first
            dir  = 1;
        }

        return { next, dir };
    }

    /* ══════════════════════════════════════════
       CROSSFADE BETWEEN TWO FRAMES
    ══════════════════════════════════════════ */
    function startFade(from, to, ts) {
        fading    = true;
        fadeFrom  = from;
        fadeTo    = to;
        fadeStart = ts;

        /* "to" starts at 0, "from" stays at 1 — both visible, stacked */
        imgs[fadeFrom].style.opacity = '1';
        imgs[fadeTo  ].style.opacity = '0';
    }

    function tickFade(ts) {
        const progress = Math.min((ts - fadeStart) / CROSSFADE_MS, 1);

        /* ease-out quad for a natural feel */
        const eased = 1 - (1 - progress) * (1 - progress);

        imgs[fadeFrom].style.opacity = String(1 - eased);
        imgs[fadeTo  ].style.opacity = String(eased);

        if (progress >= 1) {
            /* Fade done — clean up */
            imgs[fadeFrom].style.opacity = '0';
            imgs[fadeTo  ].style.opacity = '1';
            current = fadeTo;
            fading  = false;
        }
    }

    /* ══════════════════════════════════════════
       SHOW FIRST FRAME INSTANTLY
    ══════════════════════════════════════════ */
    imgs[0].style.opacity = '1';

    /* ══════════════════════════════════════════
       MAIN TICK
    ══════════════════════════════════════════ */
    function tick(ts) {
        requestAnimationFrame(tick);

        /* If currently cross-fading, keep animating the blend */
        if (fading) {
            tickFade(ts);
            return;   // don't advance frame until fade is done
        }

        /* Time to advance? */
        if (lastTime === null) lastTime = ts;
        const elapsed = ts - lastTime;

        if (elapsed >= FRAME_MS) {
            lastTime = ts - (elapsed % FRAME_MS);

            const { next, dir } = nextIndex(current, direction);
            direction = dir;

            startFade(current, next, ts);
        }
    }

    requestAnimationFrame(tick);

    /* Pause / resume on tab visibility */
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) lastTime = null;
    });

})();
</script>

</body>
</html>